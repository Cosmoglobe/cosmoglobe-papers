%                                                                 aa.dem
% AA vers. 9.1, LaTeX class for Astronomy & Astrophysics
% demonstration file
%                                                       (c) EDP Sciences
%-----------------------------------------------------------------------
%
% \documentclass[referee]{aa} % for a referee version
%\documentclass[onecolumn]{aa} % for a paper on 1 column  
%\documentclass[longauth]{aa} % for the long lists of affiliations 
%\documentclass[letter]{aa} % for the letters 
%\documentclass[bibyear]{aa} % if the references are not structured 
%                              according to the author-year natbib style

%

\documentclass{article}  

%
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{natbib}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{txfonts}
\usepackage{xcolor}

\usepackage{blindtext}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \usepackage[options]{hyperref}
% To add links in your PDF file, use the package "hyperref"
% with options according to your LaTeX or PDFLaTeX drivers.
\usepackage{float}
%\usepackage{stfloats}
\usepackage{dblfloatfix}
\usepackage{afterpage}
\usepackage{ifthen}
\usepackage[morefloats=12]{morefloats}

\usepackage{placeins}
\usepackage{multicol}
%\usepackage[breaklinks,colorlinks,citecolor=blue]{hyperref}
\bibpunct{(}{)}{;}{a}{}{,}
\usepackage[switch]{lineno}
\definecolor{linkcolor}{rgb}{0.6,0,0}
\definecolor{citecolor}{rgb}{0,0,0.75}
\definecolor{urlcolor}{rgb}{0.12,0.46,0.7}
\usepackage[breaklinks, colorlinks, urlcolor=urlcolor,
    linkcolor=linkcolor,citecolor=citecolor,pdfencoding=auto]{hyperref}
\hypersetup{linktocpage}
\usepackage{bold-extra}

\usepackage{subcaption} % for subfigures
% new command for to dos
\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO:} #1}}

\input{Planck}

% Custom definitions
%\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}
\def\Cosmoglobe{\textsc{Cosmoglobe}}
\def\commanderthree{\texttt{Commander3}}
\def\commander{\texttt{Commander}}
\def\Planck{\textit{Planck}}
\def\WMAP{\textit{WMAP}}
\def\COBE{\textit{COBE}}
\def\GAIA{\textit{Gaia}}
\def\gaia{\textit{Gaia}}
\def\Gaia{\textit{Gaia}}
\def\WISE{WISE}
\def\AKARI{\textrm{{AKARI}}}
\def\IRAS{\textrm{{IRAS}}}

\newcommand{\CII}{\ensuremath{\textsc{C\,ii}}}

\newcommand{\phm}{\phantom{-}}
\newcommand{\dv}[0]{\vec{d}}
\renewcommand{\t}[0]{\vec{t}}
\newcommand{\A}[0]{\tens{A}}
\newcommand{\B}[0]{\tens{B}}
\newcommand{\Y}[0]{\tens{Y}}
\newcommand{\G}[0]{\tens{G}}
\newcommand{\n}[0]{\vec{n}}
\newcommand{\red}[0]{\color{red}}
\newcommand{\green}[0]{\color{green}}
\newcommand{\s}[0]{\vec{s}}
\renewcommand{\a}[0]{\vec{a}}
\newcommand{\m}[0]{\vec{m}}
\newcommand{\bv}[0]{\vec{b}}
\newcommand{\f}[0]{\vec{f}}
\newcommand{\F}[0]{\tens{F}}
\newcommand{\T}[0]{\tens{T}}
\newcommand{\Cp}[0]{\tens{C}}
\renewcommand{\L}[0]{\tens{L}}
\newcommand{\g}[0]{\vec{g}}
\newcommand{\N}[0]{\tens{N}}
\newcommand{\M}[0]{\tens{M}}
\newcommand{\iN}[0]{\tens{N}^{-1}}
\newcommand{\iM}[0]{\tens{M}^{-1}}
\newcommand{\w}[0]{\vec{w}}
\renewcommand{\S}[0]{\tens{S}}
\renewcommand{\r}[0]{\vec{r}}
\renewcommand{\u}[0]{\vec{u}}
\newcommand{\q}[0]{\vec{q}}
\renewcommand{\v}[0]{\vec{v}}
\renewcommand{\P}[0]{\tens{P}}
\newcommand{\dt}[0]{d_t}
\newcommand{\di}[0]{d_i}
\newcommand{\nt}[0]{n_t}
\newcommand{\st}[0]{s_t}
\newcommand{\mt}[0]{m_t}
\newcommand{\ft}[0]{f_t}
\newcommand{\Te}[0]{T_{\rm e}}
\newcommand{\EM}[0]{\rm EM}
\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}
\newcommand{\hi}{\ensuremath{\mathsc {H\,i}}}
\newcommand{\bpbold}{\bfseries{\scshape{BeyondPlanck}}}
\newcommand{\BP}{\textsc{BeyondPlanck}}
\newcommand{\bp}{\textsc{BeyondPlanck}}
\newcommand{\cosmoglobe}{\textsc{Cosmoglobe}}
%\newcommand{\Cosmoglobe}{\textsc{Cosmoglobe}}
\newcommand{\lfi}[0]{LFI}
\newcommand{\hfi}[0]{HFI}
\newcommand{\npipe}[0]{\texttt{NPIPE}}
\newcommand{\sroll}[0]{\texttt{SRoll}}
\newcommand{\K}[0]{\textit K}
\newcommand{\Ka}[0]{\textit{Ka}}
\newcommand{\Q}[0]{\textit Q}
\newcommand{\V}[0]{\textit V}
\newcommand{\W}[0]{\textit W}
\newcommand{\e}{\mathrm e}
\newcommand{\cvar}{\ensuremath{c(\vartheta, \varphi, \psi)}}


\def\Tcmb{\ifmmode T_\mathrm{CMB}\else $T_{\mathrm{CMB}}$\fi}
\def\Tcold{\ifmmode T_\mathrm{c}\else $T_{\mathrm{c}}$\fi}
\def\Thot{\ifmmode T_\mathrm{h}\else $T_{\mathrm{h}}$\fi}
\def\Tnear{\ifmmode T_\mathrm{n}\else $T_{\mathrm{n}}$\fi}
\def\scmb{\ifmmode s_\mathrm{CMB}\else $s_{\mathrm{CMB}}$\fi}
\def\squad{\ifmmode s_\mathrm{quad}\else $s_{\mathrm{quad}}$\fi}
\def\ssynch{\ifmmode s_\mathrm{s}\else $s_\mathrm{s}$\fi}
\def\sdust{\ifmmode s_\mathrm{d}\else $s_{\mathrm{d}}$\fi}
\def\ssdust{\ifmmode s_\mathrm{sd}\else $s_{\mathrm{sd}}$\fi}
\def\same{\ifmmode s_\mathrm{AME}\else $s_{\mathrm{AME}}$\fi}
\def\ssrc{\ifmmode s_\mathrm{src}\else $s_{\mathrm{src}}$\fi}
\def\sco{\ifmmode s_\mathrm{CO}\else $s_{\mathrm{CO}}$\fi}
\def\sff{\ifmmode s_\mathrm{ff}\else $s_{\mathrm{ff}}$\fi}
\def\gff{\ifmmode g_\mathrm{ff}\else $g_{\mathrm{ff}}$\fi}
\def\fsynch{\ifmmode f_\mathrm{s}\else $f_{\mathrm{s}}$\fi}
\def\fsd{\ifmmode f_\mathrm{sd}\else $f_{\mathrm{sd}}$\fi}
\def\fame{\ifmmode f_\mathrm{AME}\else $f_{\mathrm{AME}}$\fi}
\def\alphasrc{\ifmmode \alpha_\mathrm{src}\else $\alpha_{\mathrm{src}}$\fi}
\def\bcold{\ifmmode \beta_\mathrm{c}\else $\beta_{\mathrm{c}}$\fi}
\def\bhot{\ifmmode \beta_\mathrm{h}\else $\beta_{\mathrm{h}}$\fi}
\def\bnear{\ifmmode \beta_\mathrm{n}\else $\beta_{\mathrm{n}}$\fi}
\def\bsynch{\ifmmode \beta_\mathrm{s}\else $\beta_{\mathrm{s}}$\fi} 
\def\bsun{\ifmmode \beta_\mathrm{sun}\else $\beta_{\mathrm{sun}}$\fi} 
\def\nuzeros{\ifmmode \nu_{0,\mathrm{s}}\else $\nu_{0,\mathrm{s}}$\fi} 
\def\nuzeroff{\ifmmode \nu_{0,\mathrm{ff}}\else $\nu_{0,\mathrm{ff}}$\fi} 
\def\nuzerocold{\ifmmode \nu_{0,\mathrm{c}}\else $\nu_{0,\mathrm{c}}$\fi}
\def\nuzerohot{\ifmmode \nu_{0,\mathrm{h}}\else $\nu_{0,\mathrm{h}}$\fi}
\def\nuzeronear{\ifmmode \nu_{0,\mathrm{n}}\else $\nu_{0,\mathrm{n}}$\fi} 
\def\nuzeroame{\ifmmode \nu_{0,\mathrm{AME}}\else $\nu_{0,\mathrm{AME}}$\fi} 
\def\nuzerosd{\ifmmode \nu_{0,\mathrm{}}\else $\nu_{0,\mathrm{sd}}$\fi} 
\def\nuzerosrc{\ifmmode \nu_{0,\mathrm{src}}\else $\nu_{0,\mathrm{src}}$\fi} 
\def\nup{\ifmmode \nu_{\mathrm{p}}\else $\nu_{\mathrm{p}}$\fi} 
\def\alphasd{\ifmmode \alpha_{\mathrm{sd}}\else $\alpha_{\mathrm{sd}}$\fi} 
\def\Te{\ifmmode T_{\mathrm{e}}\else $T_{\mathrm{e}}$\fi} 
\def\kB{\ifmmode k_\mathrm{B}\else $k_{\mathrm{B}}$\fi} 


\begin{document} 

   \title{\bfseries{\Cosmoglobe\ DR3. II. Mapmaking with interferograms}}

   \input{authors.tex}

   %\institute{Institute of Theoretical Astrophysics, University of Oslo, Blindern, Oslo, Norway}
  
   % Shortened title, author list for top of page 
   %\titlerunning{\Cosmoglobe: DIRBE reanalysis}
   %\authorrunning{D.~Watts et al.}

   \date{\today} 
   
   \abstract{Sometimes a mapmaker is worth a whole paper.}

%    \keywords{DTF matrix}

	\textbf{Keywords:} DTF matrix

   \maketitle

%\setcounter{tocdepth}{2}
%\tableofcontents
   

% INTRODUCTION
%-------------------------------------------------------------------
\section{Introduction}
%\the\textwidth \the\columnwidth

The basic idea is as follows. If you are looking at a smooth emitter with spectrum $S(\nu)$, an interferogram essentially lets you take the Fourier transform.
\[
	I(d)=\int_0^\infty S(\nu)\cos(2\pi d\nu)\,\mathrm d\nu
\]
where $d$ is the moving mirror position.\footnote{We are assuming here that the internal calibrator on FIRAS has been taken care of already.} This can be recast as a linear operator, $\mathsf F$ (called so because it is the real part of a Fourier transform), and allows us to write
\[
	I_d = F_{d\nu}S_\nu.
\]
Note that we've implicitly discretized things here, which is of course an approximation.

When FIRAS observed, it would collect data as it was pointing at a position on the sky; let's call this $p$, which could stand for $p$ixel or $p$osition. What is the spectrum at the point on the sky? Well, if we have a sky model, we can write this as
\[
	S_\nu(p)=\sum_c a_{c,p}f_c(\nu\mid\beta_{p})
\]
where $c$ indexes all the components we care about; mostly thermal dust, the CMB, and the CIB, and $\beta_p$ is the generalized (potentially) spatially-dependent spectral parameters, $f_c(\nu\mid\beta_p)$ the frequency dependence, and $a_{c,p}$ a component map on the sky. This also can be cast as a series of matrix equations. One way of looking at it is this;
\[
	S_{\nu p}=M_{\nu p, c}a_{c,p}
\]
where $\mathsf M$ takes us from a component amplitude space to a spectrum space.

Where we could get tripped up now is that this spectrum itself has a position dependence; this is where we would the pointing matrix $\mathsf P$, where
\[
	S_{\nu t}=P_{tp}S_{\nu p}.
\]
We are now doing the physicist thing where different objects have the same variable names. We must fix this for clarity's sake later.

Now the fun thing is that FIRAS is moving while the interferogram is being taken. Let's pretend that we don't even want to know what the components are, we just want maps; now $S_{\nu,p}$ is the object we want to recover.
\[
	I_d = F_{dt}P_{tp}S_{p\nu}
\]
In words, $d$ is the distance of the mirror, $t$ is the time that we observe, $p$ is the position the telescope is looking at.

Because there is always noise, let us add noise;
\[
	I_d =F_{dt}P_{tp}S_{p\nu}+n_t
\]

There are two different ways to go here. One is, for each $I_d$, we perform the inverse Fourier transform, then do some mapmaking.
\[
	I_d\to F^{-1}I_d\to \hat S_{p\nu}=\frac1{N_\mathrm{obs}}\sum F^{-1}I_d
\]
There's a bit more to it, but not much. There is of course noise weighting that can be used as well.

Another way to look at this is through the standard mapmaking equation with a twist;
\[
	\mathsf I=\mathsf{FPS}+\boldsymbol n
\]
Here, given $\mathsf F$, $\mathsf P$, $\mathsf I$, and $\mathsf N=\langle\boldsymbol n^T\boldsymbol n\rangle$, there is a maximum likelihood solution;
\[
	[(\mathsf{FP})^T\mathsf N^{-1}\mathsf{FP}]\hat{\mathsf S}
	=(\mathsf{FP})^T\mathsf N^{-1}\mathsf I
\]
Incidentally, $\mathsf S$ looks a bit scary at first because it is a matrix. In practice, we can reshape it so that instead of a $N_p\times N_\nu$ matrix, we can stack columns to obtain one $N_pN_\nu$-length vector.

In principle, this is it. There are other advantages here as well; some things, like the apodization function and the optical transfer function like to push the signal to zero. Can we avoid this here?

This should roughly reduce to the usual approach, if we pretend that $\mathsf P$ is invertible;
\begin{align*}
	\hat{\mathsf S}&=
	[(\mathsf{FP})^T\mathsf N^{-1}\mathsf{FP}]^{-1}(\mathsf{FP})^T\mathsf N^{-1}\mathsf I
	\\
	&\approx (\mathsf{FP})^{-1}\mathsf I
\end{align*}
which completely agrees with the idea from before.

Where this idea can really help is with the averaging; 4--12 IFG's are averaged on board, so the true data model is a bit more complex;
\[
	I_d=\sum_{i}(F_{dt_i}P_{t_i p}S_{p\nu}+n_{t_i})\footnote{\textrm{Or averaged; not important right now}}
\]
This can create some blurring in the scanning direction, and potentially splitting in regions with high gradients. It is not clear to me yet how this was avoided in the original FIRAS pipeline.


\section{Regarding the Fourier transformations}

Everything useful about the Fourier transform, the DTF and specifically the real DTF: \href{https://www.dspguide.com/ch8/1.htm}{here}.

\subsection{Matrix Inversion Method}

So we want to start with the simplest case, where we are able to start from
\begin{equation}
	d = Pm + n,
\end{equation}
and through the maximum likelihood method get to
\begin{equation}
	P^T N^{-1}P \hat m = p^T N^{-1}d
\end{equation}
and simply invert the left hand side to get
\begin{equation}
	\hat m = (P^T N^{-1}P)^{-1}P^T N^{-1}d.
\end{equation}

Now, it's important to define $P$, which, for starters, will simply be the DFT matrix, which we will call $W$. Also, let's go even simpler and say that simply
\begin{equation}
	m = P^{-1}d.
\end{equation}

Now, what is $P^{-1}$? \href{https://www.youtube.com/watch?v=Er-FcErLXrQ}{This guy} explains it pretty well.

A Fourier transform is defined as 
\begin{equation}
	\tilde x[k] = \sum_{n=0}^{N-1} e^{-j\frac{2\pi kn}{N}} x[n],
\end{equation}
which shows that the DFT matrix operator can be writen as
\begin{equation}
	W_{kn} = e^{-j\frac{2\pi kn}{N}},
\end{equation}
where we $W_{kn}$ is the $k$th element of the $n$th row of $W$. $j$ is of course the imaginary unit (DSP engineers... it was always gonna have to come to them).

The inverse Fourier transform is defined as
\begin{equation}
	x[n]=\frac{1}{N} \sum_{n=0}^{N-1} \tilde x[k] e^{+j\frac{2\pi kn}{N}},
\end{equation}
which then similarly defines the inverse DFT matrix as
\begin{equation}
	W^{-1}_{nk} = \frac{1}{N} e^{+j\frac{2\pi kn}{N}},
\end{equation}
which we can relate to the DFT matrix via matrix operations:
\begin{align}
	W^{-1}_{nk} &= \frac{1}{N} (e^{-j\frac{2\pi kn}{N}})^*\\
	&= \frac{1}{N} (W)^*_{nk}\\
	&= \frac{1}{N} (W^{*^T})_{kn},
\end{align}
which is just the hermitian conjugate, perfect!

\subsection{The curse of using Fourier transforms on real-valued input}

This would be perfect and very easy if we were using complex-valued input, where the full $N$ points of the transform are relevant.
However, our signal is real-valued, and carrying around a copy of the transform is not very useful and only gives way to more calculations.
One would think that we could build a real DFT matrix (i.e. a matrix operator that is equivalent to the real Fourier transform).
As such, we need to build a matrix that is $N/2+1$ by $N$, which, of course, is not square, and therefore we lose the nice unitary (up to a normalization factor) properties of the DFT matrix.
Still, we can try to work it out on the same principle that the inverse operator is the same as the transpose operator (up to a normalization factor) and see what happens.
This is probably the questionable assumption that I'm making.

So, this is how we define the real DFT matrix:
\begin{align}
	&\omega = e^{-2\pi i / N}\\
	&W^r_{\nu_i x_i} = \omega^{\nu_i x_i},
\end{align}
and this matrix works on the real-valued input as expected, the same as using the numpy.fft.rfft function.

We can also visualise what the operators look like in Figure \ref{fig:dft}.

\begin{figure}[ht]
	\centering
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/dft.png}
	  \caption{Square DFT.}
	  \label{fig:dft-square}
	\end{subfigure}
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/dft_non_square.png}
	  \caption{Non-square DFT.}
	  \label{fig:dft-non-square}
	\end{subfigure}
	\caption{Visual representations of the forward matrix operators.}
	\label{fig:dft}
\end{figure}

Now we need the inverse operator, which then needs to be $N$ by $N/2+1$.
If the assumption that the transpose matrix is the inverse operator holds, then building the inverse operator from the definition of the inverse Fourier transform should work.
The closest I have been able to come up with is the following definition:
\begin{align}
	&\omega = e^{2\pi i / N}\\
	&W^{r^{-1}}_{x_i \nu_i} = \frac{1}{N/2 +1} (\omega^{\nu_i x_i} - 1).
\end{align}

The matrix operators are shown in Figure \ref{fig:idft}.

\begin{figure}[ht]
	\centering
	\begin{subfigure}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Figures/idft.png}
		\caption{Square inverse DFT.}
		\label{fig:idft-square}
	\end{subfigure}
	\begin{subfigure}{.45\textwidth}
		\centering
		\includegraphics[width=\linewidth]{Figures/idft_non_square.png}
		\caption{Non-square inverse DFT.}
		\label{fig:idft-non-square}
	\end{subfigure}
	\caption{Visual representations of the inverse matrix operators.}
	\label{fig:idft}
\end{figure}

Nothing seems obviously wrong with the non-square version of the operator.
However, Figure \ref{fig:problems} shows what the matrix multiplication of the forward and inverse operators ($W^{r^{-1}}W^r$) looks like (which we expect to be the identity matrix) and the close-up of the difference between the original real-valued input and the output after putting it through our built non-square DFT and inverse DFT operators.

\begin{figure}[ht]
	\centering
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/multiplied.png}
	  \caption{Multiplication of the forward and inverse operators.}
	  \label{fig:problems-multiplication}
	\end{subfigure}
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/bumps.png}
	  \caption{Close-up of the difference between the original and the output.}
	  \label{fig:problems-closeup}
	\end{subfigure}
	\caption{Visual representations of the problems with the non-square inverse DFT.}
	\label{fig:problems}
\end{figure}

I also tried simply taking the hermitian conjugate of the DFT matrix instead of building the inverse DFT matrix "from scratch" and that seems to wield the same results.

\section{Mapmaking for FTS}

When looking at each individual interferogram (and therefore only looking at one pixel), there is a fairly simple matrix formulation of the maximum likelihood mapmaking equation, which which relates the spatial distance in the instrument $x$ with sky frequency $\nu$ and reads
\begin{equation}
	(F^T_{\nu; x} N^{-1}_{x;x} F_{x;\nu}) m_\nu = F^T_{\nu; x} N^{-1}_{x;x} d_x,
\end{equation}
where ; in the index separates the two dimensions of the matrix.

Now the standard mapmaking equation relates time $t$ with position in the sky $p$ and reads
\begin{equation}
	(P^T_{p;t} N^{-1}_{t;t} P_{t;p})m_p = P^T_{p;t} N^{-1}_{t;t}d_t.
\end{equation}

Now in order to be able to treat pixel correlations, we need to put the two together, which I think will look like this:
\begin{equation}
	(P^T_{\nu p;\nu}F^T_{\nu;xt} N^{-1}_{xt;xt} F_{xt;\nu}P_{\nu;\nu p})m_{\nu p} = P^T_{\nu p;\nu}F^T_{\nu;xt} N^{-1}_{xt;xt}d_{xt}.
\end{equation}

\subsection{Revised data model and corresponding ML mapmaking equation}

After speaking to Sigurd, he came up (somewhat independently) with the following data model:
\begin{equation}
	d_i = P_i F T_i m + n,
\end{equation}
where $i$ for the FIRAS case would correspond to temperature bins. And the corresponding ML mapmaking equation would then be:
\begin{equation}
	\hat m = \left(\sum_i T_i^T F^T P_i^T N^{-1} P_i F T \right)^{-1} \sum_i T_i^T F^T P^T N^{-1} d_i,
\end{equation}
where $F$ here should be cosine transforms.

We spoke about it after and mentioned that it actually might make more sense to add the ICAL (and others) back in when the data is in IFG space, which then even can ignore these temperature bins.
This would probably mean that we need to do all other low-level IFG processing before entering this "pipeline" too, like removing the transient reponse from the  onboard digital filters, etc.

\subsection{Mapmaking without taking into account frequency correlations}

For the sake of starting with something simple, we will assume that we have white noise and no frequency correlations (which is not true, the current noise estimate (without taking into account frequency correlations) for FIRAS is shown in Figure \ref{fig:noise-estimation}, which seems to be white + blue noise).

\begin{figure}[ht]
	\centering
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/cov.png}
	  \caption{Noise covariance matrix not taking into account frequency correlations (size is 512 x 512). In order to subtract the signal to estimate this, I simply subtracted one IFG from the next and so on.}
	  \label{fig:cov-matrix}
	\end{subfigure}
	\begin{subfigure}{.45\textwidth}
	  \centering
	  \includegraphics[width=\linewidth]{Figures/psd.png}
	  \caption{Noise PSD not taking into account frequency correlations (Fourier transform was made along NIFG). In order to subtract the signal to estimate this, I simply subtracted one IFG from the next and so on.}
	  \label{fig:psd}
	\end{subfigure}
	\caption{Noise estimations without taking into account frequency correlations.}
	\label{fig:noise-estimation}
\end{figure}

I now believe that there is no difference in where we place the (let's call it) space distance Fourier transform $F_x$ in relation to the pointing matrix in our data model, if we are considering a stop and stare approach (which we are for now), because it is the same to first bin and then take the Fourier transform or vice-versa. Taking this into account, the most efficient way to program is taking the Fourier transform of the following after binning:

\begin{equation}
	\hat m_p = \frac{\sum_{i \in p}\frac{d_i}{\sigma_i^2}}{\sum_{i \in p}\frac{1}{\sigma_i^2}}.
\end{equation}

For now we are also assuming an instrument that is not differential, i.e. there is no sutraction of an internal calibration because, even though FIRAS is differential, a general FTS does not need to be. In order to take this into account, the two options are to either consider a completely different equation and Fourier transform as the first step and then subtract in sky frequency space or to leave it as is and subtract in interferogram space.

%-------------------------------------------------------------
%                                       Table with references 
%-------------------------------------------------------------
%

\bibliographystyle{aa}
\bibliography{../../common/CG_bibliography,../../common/Planck_bib}
\end{document}
%%%% End of aa.dem
