%                                                                 aa.dem
% !TEX root = /mn/stornext/u3/aimartin/d5/cosmoglobe-papers/FIRAS/ifg_mapmaking/main.tex
% AA vers. 9.1, LaTeX class for Astronomy & Astrophysics
% demonstration file
%                                                       (c) EDP Sciences
%-----------------------------------------------------------------------
%
% \documentclass[referee]{aa} % for a referee version
%\documentclass[onecolumn]{aa} % for a paper on 1 column  
%\documentclass[longauth]{aa} % for the long lists of affiliations 
%\documentclass[letter]{aa} % for the letters 
%\documentclass[bibyear]{aa} % if the references are not structured 
%                              according to the author-year natbib style

%

\documentclass{aa}  

%
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{natbib}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{txfonts}
\usepackage{xcolor}

\usepackage{blindtext}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \usepackage[options]{hyperref}
% To add links in your PDF file, use the package "hyperref"
% with options according to your LaTeX or PDFLaTeX drivers.
\usepackage{float}
%\usepackage{stfloats}
\usepackage{dblfloatfix}
\usepackage{afterpage}
\usepackage{ifthen}
\usepackage[morefloats=12]{morefloats}

\usepackage{placeins}
\usepackage{multicol}
%\usepackage[breaklinks,colorlinks,citecolor=blue]{hyperref}
\bibpunct{(}{)}{;}{a}{}{,}
\usepackage[switch]{lineno}
\definecolor{linkcolor}{rgb}{0.6,0,0}
\definecolor{citecolor}{rgb}{0,0,0.75}
\definecolor{urlcolor}{rgb}{0.12,0.46,0.7}
\usepackage[breaklinks, colorlinks, urlcolor=urlcolor,
    linkcolor=linkcolor,citecolor=citecolor,pdfencoding=auto]{hyperref}
\hypersetup{linktocpage}
\usepackage{lastpage}
\usepackage{bold-extra}


\usepackage{subcaption} % for subfigures
% new command for to dos
\newcommand{\todo}[1]{\textcolor{red}{\textbf{TODO:} #1}}

\input{Planck}

% Custom definitions
%\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}
\def\Cosmoglobe{\textsc{Cosmoglobe}}
\def\commanderthree{\texttt{Commander3}}
\def\commander{\texttt{Commander}}
\def\Planck{\textit{Planck}}
\def\WMAP{\textit{WMAP}}
\def\COBE{\textit{COBE}}
\def\GAIA{\textit{Gaia}}
\def\gaia{\textit{Gaia}}
\def\Gaia{\textit{Gaia}}
\def\WISE{WISE}
\def\AKARI{\textrm{{AKARI}}}
\def\IRAS{\textrm{{IRAS}}}
\renewcommand{\P}[0]{\tens{P}}

\newcommand{\CII}{\ensuremath{\textsc{C\,ii}}}

\newcommand{\phm}{\phantom{-}}
\newcommand{\dv}[0]{\vec{d}}
\newcommand{\D}[0]{\tens{D}}
\renewcommand{\t}[0]{\vec{t}}
\newcommand{\A}[0]{\tens{A}}
\newcommand{\B}[0]{\tens{B}}
\newcommand{\Y}[0]{\tens{Y}}
\newcommand{\G}[0]{\tens{G}}
\newcommand{\n}[0]{\vec{n}}
\newcommand{\red}[0]{\color{red}}
\newcommand{\green}[0]{\color{green}}
\newcommand{\s}[0]{\vec{s}}
\renewcommand{\a}[0]{\vec{a}}
\newcommand{\m}[0]{\vec{m}}
\newcommand{\bv}[0]{\vec{b}}
\newcommand{\f}[0]{\vec{f}}
\newcommand{\F}[0]{\tens{F}}
\newcommand{\T}[0]{\tens{T}}
\newcommand{\Cp}[0]{\tens{C}}
\renewcommand{\L}[0]{\tens{L}}
\newcommand{\g}[0]{\vec{g}}
\newcommand{\N}[0]{\tens{N}}
\newcommand{\M}[0]{\tens{M}}
\newcommand{\iN}[0]{\tens{N}^{-1}}
\newcommand{\iM}[0]{\tens{M}^{-1}}
\newcommand{\w}[0]{\vec{w}}
\renewcommand{\S}[0]{\tens{S}}
\renewcommand{\r}[0]{\vec{r}}
\renewcommand{\u}[0]{\vec{u}}
\newcommand{\q}[0]{\vec{q}}
\renewcommand{\v}[0]{\vec{v}}
\newcommand{\matP}[0]{\tens{P}}
\newcommand{\dt}[0]{d_t}
\newcommand{\di}[0]{d_i}
\newcommand{\nt}[0]{n_t}
\newcommand{\st}[0]{s_t}
\newcommand{\mt}[0]{m_t}
\newcommand{\ft}[0]{f_t}
\newcommand{\Te}[0]{T_{\rm e}}
\newcommand{\EM}[0]{\rm EM}
\newcommand{\mathsc}[1]{{\normalfont\textsc{#1}}}
\newcommand{\hi}{\ensuremath{\mathsc {H\,i}}}
\newcommand{\bpbold}{\bfseries{\scshape{BeyondPlanck}}}
\newcommand{\BP}{\textsc{BeyondPlanck}}
\newcommand{\bp}{\textsc{BeyondPlanck}}
\newcommand{\cosmoglobe}{\textsc{Cosmoglobe}}
%\newcommand{\Cosmoglobe}{\textsc{Cosmoglobe}}
\newcommand{\lfi}[0]{LFI}
\newcommand{\hfi}[0]{HFI}
\newcommand{\npipe}[0]{\texttt{NPIPE}}
\newcommand{\sroll}[0]{\texttt{SRoll}}
\newcommand{\K}[0]{\textit K}
\newcommand{\Ka}[0]{\textit{Ka}}
\newcommand{\Q}[0]{\textit Q}
\newcommand{\V}[0]{\textit V}
\newcommand{\W}[0]{\textit W}
\newcommand{\e}{\mathrm e}
\newcommand{\cvar}{\ensuremath{c(\vartheta, \varphi, \psi)}}


\def\Tcmb{\ifmmode T_\mathrm{CMB}\else $T_{\mathrm{CMB}}$\fi}
\def\Tcold{\ifmmode T_\mathrm{c}\else $T_{\mathrm{c}}$\fi}
\def\Thot{\ifmmode T_\mathrm{h}\else $T_{\mathrm{h}}$\fi}
\def\Tnear{\ifmmode T_\mathrm{n}\else $T_{\mathrm{n}}$\fi}
\def\scmb{\ifmmode s_\mathrm{CMB}\else $s_{\mathrm{CMB}}$\fi}
\def\squad{\ifmmode s_\mathrm{quad}\else $s_{\mathrm{quad}}$\fi}
\def\ssynch{\ifmmode s_\mathrm{s}\else $s_\mathrm{s}$\fi}
\def\sdust{\ifmmode s_\mathrm{d}\else $s_{\mathrm{d}}$\fi}
\def\ssdust{\ifmmode s_\mathrm{sd}\else $s_{\mathrm{sd}}$\fi}
\def\same{\ifmmode s_\mathrm{AME}\else $s_{\mathrm{AME}}$\fi}
\def\ssrc{\ifmmode s_\mathrm{src}\else $s_{\mathrm{src}}$\fi}
\def\sco{\ifmmode s_\mathrm{CO}\else $s_{\mathrm{CO}}$\fi}
\def\sff{\ifmmode s_\mathrm{ff}\else $s_{\mathrm{ff}}$\fi}
\def\gff{\ifmmode g_\mathrm{ff}\else $g_{\mathrm{ff}}$\fi}
\def\fsynch{\ifmmode f_\mathrm{s}\else $f_{\mathrm{s}}$\fi}
\def\fsd{\ifmmode f_\mathrm{sd}\else $f_{\mathrm{sd}}$\fi}
\def\fame{\ifmmode f_\mathrm{AME}\else $f_{\mathrm{AME}}$\fi}
\def\alphasrc{\ifmmode \alpha_\mathrm{src}\else $\alpha_{\mathrm{src}}$\fi}
\def\bcold{\ifmmode \beta_\mathrm{c}\else $\beta_{\mathrm{c}}$\fi}
\def\bhot{\ifmmode \beta_\mathrm{h}\else $\beta_{\mathrm{h}}$\fi}
\def\bnear{\ifmmode \beta_\mathrm{n}\else $\beta_{\mathrm{n}}$\fi}
\def\bsynch{\ifmmode \beta_\mathrm{s}\else $\beta_{\mathrm{s}}$\fi} 
\def\bsun{\ifmmode \beta_\mathrm{sun}\else $\beta_{\mathrm{sun}}$\fi} 
\def\nuzeros{\ifmmode \nu_{0,\mathrm{s}}\else $\nu_{0,\mathrm{s}}$\fi} 
\def\nuzeroff{\ifmmode \nu_{0,\mathrm{ff}}\else $\nu_{0,\mathrm{ff}}$\fi} 
\def\nuzerocold{\ifmmode \nu_{0,\mathrm{c}}\else $\nu_{0,\mathrm{c}}$\fi}
\def\nuzerohot{\ifmmode \nu_{0,\mathrm{h}}\else $\nu_{0,\mathrm{h}}$\fi}
\def\nuzeronear{\ifmmode \nu_{0,\mathrm{n}}\else $\nu_{0,\mathrm{n}}$\fi} 
\def\nuzeroame{\ifmmode \nu_{0,\mathrm{AME}}\else $\nu_{0,\mathrm{AME}}$\fi} 
\def\nuzerosd{\ifmmode \nu_{0,\mathrm{}}\else $\nu_{0,\mathrm{sd}}$\fi} 
\def\nuzerosrc{\ifmmode \nu_{0,\mathrm{src}}\else $\nu_{0,\mathrm{src}}$\fi} 
\def\nup{\ifmmode \nu_{\mathrm{p}}\else $\nu_{\mathrm{p}}$\fi} 
\def\alphasd{\ifmmode \alpha_{\mathrm{sd}}\else $\alpha_{\mathrm{sd}}$\fi} 
\def\Te{\ifmmode T_{\mathrm{e}}\else $T_{\mathrm{e}}$\fi} 
\def\kB{\ifmmode k_\mathrm{B}\else $k_{\mathrm{B}}$\fi} 


\begin{document} 

   \title{Simulations and Mapmaking for Past and Future Spectrometry-Based Cosmological Experiments}

   \input{authors.tex}

   \institute{Institute of Theoretical Astrophysics, University of Oslo, Blindern, Oslo, Norway}
  
   % Shortened title, author list for top of page 
   \titlerunning{Simulations and Mapmaking for Spectrometry-Based Experiments}
   \authorrunning{Silva Martins et al.}

   \date{\today} 
   
   \abstract{Sometimes a mapmaker is worth a whole paper.}

%    \keywords{DTF matrix}

	%\textbf{Keywords:} DTF matrix

   \maketitle

%\setcounter{tocdepth}{2}
%\tableofcontents
   

% INTRODUCTION
%-------------------------------------------------------------------
\section{Introduction and Motivation}
\label{sec:intro}

\todo{speak about solving the ml mapmaking equation not straight because it's impossible so we need to use CG and we need to use the ML mapmaking equation not simplified to the white noise solution because there are possibly correlations because of the moving of the beam while the fourier transform is being taken}

\section{Simulations}

In order to validate our proposed mapmaking algorithms, we first need to create a dataset to serve as our ground truth. We will assume the sky is made up solely of thermal dust, as it is the dominant foreground in most FIRAS frequencies, and the true sky content does not matter, only that we can fully recover it.

For this proof-of-concept, we will simulate the sky as seen by a Fourier-transform spectrometer (FTS) and take reference experiment parameters \todo{I don't like this wording} (e.g. scanning speed, duration of one scan, etc.) from the FIRAS experiment \citep{fixsen:1994,mather:1999}, but this method is easily generalized to any spectroscopy-based experiments with this kind of 3-dimensional data (two spatial dimensions and one spectral dimension).

We start by taking the dust component map as given in \cite{planck2014-a12}, smoothing it with the seven degree FIRAS beam and downgrading it to an NSIDE of 32 in the HEALPix pixelization scheme \citep{healpix}, which is the closest to FIRAS's native resolution. Then, we apply the dust spectral energy density (SED), also as given in \cite{planck2014-a12}, to the downgraded map and generate a map cube, spanning the frequencies theoretically reachable by the FIRAS low spectral resolution scanning scheme (from 13 to around 3000 GHz, with a spectral resolution of 13.6 GHz). It is important to note that FIRAS had four detectors, two low-frequency and two-high frequency ones, but we simulate only one detector spanning the whole frequency range, as that feature does not interfere with the mapmaking algorithms we want to test. We then generate one interferogram for each pixel in the map, by taking the Fourier transform of the SED at that pixel. It is important to note that FIRAS and similar (proposed or under-development) instrument are differential, meaning they have an internal reference temperature which is subtracted from the sky signal, and that difference is what is measured. Here, our signal simply comes from the sky, since the differential nature of the instrument can be easily accomodated for, e.g. optimally by adding the internal reference back in before mapmaking.

In order to generate a realistic scanning strategy, we take the pointing solution from the FIRAS data when scanning in the short and slow mode\footnote{The same can be done for the other scanning modes in an identical approach, as long as it is taken into account that each mode needs to be treated separately.}. In the original science data, this is given as the pointing of the midpoint of each interferogram. However, the FIRAS beam does not stop scanning while data for one interferogram is being taken. As such, and in order to produce realistic simulations, we reconstruct the pointing solution for each one of the 512 discrete MTM separations in one interferogram. We do this by taking into account that the FIRAS line of sight traced a path along a line of approximately constant ecliptic longitude while moving at 3.5 degrees per minute, as given by \cite{firasexsupp}. The short and slow mirror transport mechanism (MTM) mode was the most used scanning mode during the FIRAS mission, and it was the overall longest scanning mode, taking 55.36 seconds to complete taking the data for one telemetered interferogram. As such, we use this reference value in order to generate each separation's pointing, making it most obvious when wrong assumptions were made in the original considerations for mapmaking with the FIRAS data.

In reality, the FIRAS data that we now have access to does not correspond to the raw interferograms that were taken by the instrument. Since COBE did not have a high enough broadband, it was not possible to send individual ("on-board") interferograms to the ground. As such, the FIRAS team implemented a scheme where 16 or 4 interferograms were added on-board, respectively for short and long scans, before being telemetered down. We then generate two different types of simulations: a "modern experiment", in which we assume the broadband of an experiment being designed today would be enough to send down each individual on-board interferogram; and a "FIRAS-like experiment", in which we simulate the on-board coadding of interferograms.

Figure \ref{fig:ifg-pointing} shows an example of the pointing solution for one interferogram, as reconstructed by our method. It is important to point out that we construct these simulations in order to generate realistic data, but we would not be able to generate such fine-pointed data from the FIRAS data itself, since the germanium resistance thermometer (GRT) data rate would be too low (around 1 temperature point for each of the measured points is retrieved per telemetered interferogram).

\begin{figure}
      \centering
      \includegraphics[width=0.45\textwidth]{Figures/ifg_pointing.png} 
      \caption{Pointing solution for one interferogram, as reconstructed by our method. The color indicates how many out of the 512 separations are spent in each pixel.}
      \label{fig:ifg-pointing}
\end{figure}

We will describe the first method in Section \ref{sec:modern} in detail, as it is the easier to explain, followed by the simulation method for the second one in Section \ref{sec:firas-like}, which follows the same principles, with the addition of the on-board coadding step.

Once the interferograms are generated in either of the two methods, white noise with a level $\sigma$ varying between 0.001 and 0.1 is added to each interferogram.

\todo{picture explaining this}

\subsection{Modern Experiment}
\label{sec:modern}

For a modern experiment, we would have access to the 16 on-board averaged interferograms in the short and slow mode. As such, each interferogram is actually taken over 3.04 seconds\footnote{The reference 55.36 seconds time for the full short and slow scanning mode includes the turn-around time of the MTM, whereas for the modern experiment we take only into account a forward sweep.}.

We then end up with a 3-dimensional pointing matrix $\matP$, with dimensions $N_{\rm IFGs} \times N_{\rm pix} \times N_{\rm separations}$, where $N_{\rm IFGs}$ is the number of sky interferograms taken in the short and slow mode not excluded by our pre-processing, amounting to 171,678 interferograms; $N_{\rm pix}$ is the number of HEALPix pixels at NSIDE=32, which amounts to 12,288; and $N_{\rm separations}$ is the length of each interferogram, which is 512 samples. Each row of this matrix, $\matP_{i,:,:}$, contains the pointing solution for one interferogram, with each column $\matP_{i,:,j}$ being a one-hot vector indicating which pixel the instrument was pointing to at separation $j$ of interferogram $i$. This matrix is later used by the mapmaking algorithms.

However, our simulation does not end there, as we want to have one single interferogram for each of the $N_{\rm IFGs}$, not 512 for each. As such, we take each of the generated interferograms for each pixel and build a new interferogram with the parts of each of the pixels that is hit, i.e., for each of the $N_{\rm IFGs}$ interferograms, we generate $N_{\rm separations}$ interferograms (where we might generate the same exact interferogram many times, e.g. if the beam passes through four different pixels through one scan and spends the same amount of time in each of the four pixels, we will generate only four different interferograms, each repeated 128 times) and keep only the samples where the beam would have been looking at that pixel.

\todo{add picture illustrating the frankenstein IFG}

\subsection{FIRAS-like Experiment}
\label{sec:firas-like}

Since FIRAS averaged interferograms on-board before sending them to the ground, we need to follow the same procedure as described in Section \ref{sec:modern} and generate 16 "modern" interferograms which we then average. To do this realistically, and since FIRAS only took data in one direction of the MTM, we have to pay attention to when exactly the data was taken and when the MTM was turning around and not taking data. As such, we generate one interferogram taking into account the movement of the beam for the first 3.04 seconds. We then calculate where the beam would have moved to after the turn-around time is finished (0.42 seconds) and generate the second interferogram along the next 3.04 seconds, and so until, until we have generated 16 interferograms during the full 55.36 seconds. We then average these 16 interferograms to generate the final telemetered interferogram. We can do this by generating a four-dimensional pointing matrix $\matP$, with dimensions $N_{\rm IFGs} \times N_{\rm pix} \times N_{\rm separations} \times N_{\rm averaged}$, where $N_{\rm averaged}=16$ for the short and slow mode. We save this matrix to use during mapmaking (if using real data, we would need to build this matrix anyway, since we only have access to the pointing of the midpoint of each telemetered interferogram), but keep in mind that, going forward, we do not have access to the individual interferograms, only to the averaged one.

\todo{add figure of the adding of different interferograms}

\section{Mapmaking}

\todo{Derive mapmaking equation or cite. and add actual sizes of matrices that have to be flattened from the simulation}


A common approach that will be used in all three examples of mapmakers, which might not be straight forward from the data, is that we do mapmaking in interferogram space (512 total maps, one for each separation of the MTM), and only then Fourier transform the maps to sky frequency space (257 sky frequencies).

\subsection{Naive mapmaker}
\label{sec:naive-mapmaker}

\todo{Using only the middle pixel. Compare to the original analysis approach. Show both FFT before and after averaging.}

We first implement a naive mapmaker, serving as a baseline comparison for our proposed mapmaking algorithm. This mapmaker is similar to the one used by the original FIRAS team, with the exception that they did some measure of noise weighting when averaging the data, as further described by \citep{firasexsupp}.

As such, our naive pointing matrix $\matP$ is simply a two-dimensional matrix with shape $N_{\rm IFGs} \times N_{\rm pix}$, where each row $\matP_{i,:}$ is a one-hot vector indicating which pixel the instrument was pointing to at the middle sample of interferogram $i$. This matrix is then used to bin the data into a map, by simply averaging all interferograms that hit each pixel. This is equivalent to solving the mapmaking equation assuming the same level white noise for all interferograms and no noise correlations, as described by \cite{tegmark1997}.

Once we have our 512 interferogram separation maps $m_x$, we can take the real Fourier transform of each pixel along the 512 maps, obtaining, for each pixel, its spectrum $m_{\nu}$. We then end up with 257 full sky frequency maps, which we can then compare to the generated input sky at each SED frequency.

\subsection{White noise mapmaker}

We can take the mapmaking one step forward by taking into account our full point matrix $\matP$ as described in Section 2.1 for the modern experiment, or Section 2.2 for the FIRAS-like experiment. This mapmaker still assumes white noise and no noise correlations, but takes into account all samples in each interferogram when binning the data into a map and weights them according to their whit noise level.

As a reminder \citep{tegmark1997}, the maximum-likelihood (ML) mapmaking equation is given by
\begin{equation}
    (\matP^T \iN \matP)\hat{\m_x} = \matP^T \iN \dv,
    \label{eq:mapmaking}
\end{equation}
which, when assuming white noise with variance $\sigma^2$, simplifies to
\begin{equation}
    \m_x/\sigma^2 = \matP^T \dv / \sigma^2.
\end{equation}

It might be worth noting that, since our data is three-dimensional, the usual data vector $\dv$ is actually a data matrix $\D$ with dimensions $N_{\rm IFGs} \times N_{\rm separations}$, where each row $\D_{i,:}$ is the interferogram $i$. As such, our map $\m_x$ is also a map cube $\M_x$ with dimensions $N_{\rm pix} \times N_{\rm separations}$, where each row $\M_{x_{:,j}}$ is the map at interferogram separation $j$. This can be easily taken into account in a computational implementation of this method.

\subsection{CG mapmaker}

Even though the above-described method lets us take into account the fact that each interferogram isn't taken at a single pixel in the sky, it still assumes white noise and no correlations. However, we expect the movement of the beam during one interferogram to introduce correlations, which can only be treated by using the full mapmaking equation \eqref{eq:mapmaking}. In order to solve this equation in a computationally feasible way, we cannot simply invert the $\matP^T\iN \matP$ matrix. Even though our data volume is relatively small (around four gygabites for the whole of the FIRAS dataset), we are still using matrices with very big dimensions, in particular our three/four-dimensional pointing matrix $\P$, which would then need to fit into memory in order to be inverted. As such, we need to use an iterative method to solve the mapmaking equation, and we choose to use the Conjugate Gradient (CG) method, e.g. \citep{hestenes1952, shewchuk:1994}.

\section{Results}

\subsection{Binned mapmaker}

\todo{No noise weighting leads to a noise floor when taking the absolute value of the FFT.}

\subsection{White noise mapmaker}

\subsection{CG}

\subsection{Comparisons}

\section{Conclusions}

\section{Appendix}

\subsection{DFT matrix}


%-------------------------------------------------------------
%                                       Table with references 
%-------------------------------------------------------------
%

\bibliographystyle{aa}
\bibliography{../../common/CG_bibliography,../../common/Planck_bib}
\end{document}
%%%% End of aa.dem
